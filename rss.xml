<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>WindHolm - 海风与你</title><description>WindHolm 是一款基于 Astro 框架开发的清新美观且现代化个人博客主题，专为技术爱好者和内容创作者设计。该主题融合了现代 Web 技术栈，提供了丰富的功能模块和高度可定制的界面，让您能够轻松打造出专业且美观的个人博客网站。</description><link>https://windholm.dpdns.org/</link><language>zh_CN</language><item><title>C#的核心思想——面向对象</title><link>https://windholm.dpdns.org/posts/itplace-c/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/itplace-c/</guid><description>这篇博客为编程新手提供C#的基础教程，帮助你理解核心思想———面向对象。</description><pubDate>Sat, 29 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;C#的核心思想——面向对象&lt;/h1&gt;
&lt;p&gt;本指南是对 C# 语言核心概念的深度扩展，重点聚焦类（Class）、继承（Inheritance）、接口（Interface）等面向对象编程（OOP）基础。相比基础版，本版添加了更多子主题、访问修饰符细节、构造函数重载、多态机制、显式接口实现、泛型支持、异常处理集成等高级用法。所有示例基于 C# 11+ 版本（兼容 .NET 8+），并包含完整可运行代码片段。建议使用 Visual Studio 或 Rider IDE 进行测试。本文适用于编程思想的入门，对于C#的使用特性会在后续更.&lt;/p&gt;
&lt;p&gt;指南结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;理论解释&lt;/strong&gt;：概念定义与原理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语法与示例&lt;/strong&gt;：详细代码 + 输出解释。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：常见陷阱与最佳实践。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展用法&lt;/strong&gt;：高级变体。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多资源：参考 &lt;a href=&quot;https://learn.microsoft.com/zh-cn/dotnet/csharp/&quot;&gt;Microsoft C# 官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;1. 类（Class）&lt;/h2&gt;
&lt;p&gt;类是 C# OOP 的基石，用于封装数据和行为。类定义对象的结构，包括字段（数据存储）、属性（访问控制）、方法（行为逻辑）、构造函数（初始化）和析构函数（清理）。C# 类支持访问修饰符（Access Modifiers）控制可见性：&lt;code&gt;public&lt;/code&gt;（公开）、&lt;code&gt;private&lt;/code&gt;（私有，默认）、&lt;code&gt;protected&lt;/code&gt;（保护，仅派生类访问）、&lt;code&gt;internal&lt;/code&gt;（程序集内可见）、&lt;code&gt;protected internal&lt;/code&gt;（程序集内或派生类可见）、&lt;code&gt;private protected&lt;/code&gt;（派生类且同一程序集）。&lt;/p&gt;
&lt;h3&gt;1.1 基本语法与访问修饰符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类默认是 &lt;code&gt;internal&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;成员默认是 &lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;示例：完整类定义（包含访问修饰符）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;using System;

// 公共类
public class Employee
{
    // 私有字段（封装数据）
    private string id;
    private decimal salary;  // protected internal 示例：程序集内或派生类可见

    // 公共属性（自动实现，C# 3.0+）
    public string Name { get; set; } = string.Empty;

    // 保护属性（仅派生类访问）
    protected int DepartmentId { get; set; }

    // 内部属性（仅当前程序集可见）
    internal DateTime HireDate { get; private set; }  // 私有 setter

    // 构造函数重载（多种初始化方式）
    public Employee()  // 默认构造函数
    {
        id = Guid.NewGuid().ToString();
        HireDate = DateTime.Now;
    }

    public Employee(string name, decimal salary) : this()  // 链式调用默认构造函数
    {
        Name = name;
        Salary = salary;  // 通过属性设置，触发验证
    }

    // 属性带验证的 setter
    public decimal Salary
    {
        get =&amp;gt; salary;
        private set  // 私有 setter，仅类内部修改
        {
            if (value &amp;lt; 0)
                throw new ArgumentException(&quot;薪资不能为负数&quot;);
            salary = value;
        }
    }

    // 私有方法（辅助逻辑）
    private void ValidateEmployee()
    {
        if (string.IsNullOrEmpty(Name))
            throw new InvalidOperationException(&quot;姓名不能为空&quot;);
    }

    // 公共方法
    public void Promote(decimal raise)
    {
        ValidateEmployee();
        Salary += raise;  // 私有 setter 允许内部访问
        Console.WriteLine($&quot;{Name} 晋升，薪资增加 {raise:C}。&quot;);
    }

    // 静态成员（类级）
    public static int TotalEmployees { get; private set; } = 0;

    // 静态构造函数（初始化静态成员）
    static Employee()
    {
        Console.WriteLine(&quot;Employee 类静态初始化。&quot;);
    }
}

// 使用类
class Program
{
    static void Main()
    {
        Employee emp = new Employee(&quot;李四&quot;, 5000m);
        emp.Promote(1000m);  // 输出: 李四 晋升，薪资增加 ￥1,000.00。

        Console.WriteLine(Employee.TotalEmployees);  // 输出: 0（静态计数需手动增）
        Employee.TotalEmployees++;  // 手动更新
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出解释&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;静态构造函数在首次访问类时运行。&lt;/li&gt;
&lt;li&gt;属性 setter 验证确保数据完整性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.2 注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不可变类&lt;/strong&gt;（C# 9.0+）：使用 &lt;code&gt;init&lt;/code&gt; 仅允许初始化时设置，如 &lt;code&gt;public string Name { get; init; }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录类型&lt;/strong&gt;（Record，C# 9.0+）：简洁不可变类，如 &lt;code&gt;public record Person(string Name, int Age);&lt;/code&gt;（自动生成相等比较）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嵌套类&lt;/strong&gt;：类内定义类，如 &lt;code&gt;public class Outer { private class Inner { } }&lt;/code&gt;（仅 Outer 访问）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分类&lt;/strong&gt;（Partial Class）：跨文件定义，如 &lt;code&gt;partial class MyClass { }&lt;/code&gt; 和另一个文件 &lt;code&gt;partial class MyClass { }&lt;/code&gt;（用于代码生成）。&lt;/li&gt;
&lt;li&gt;陷阱：忘记 &lt;code&gt;new&lt;/code&gt; 关键字实例化会导致编译错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.3 扩展用法：析构函数与 IDisposable&lt;/h3&gt;
&lt;p&gt;类可实现 &lt;code&gt;IDisposable&lt;/code&gt; 接口进行资源管理（详见接口部分）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ResourceHolder : IDisposable
{
    private bool disposed = false;

    public void Dispose()
    {
        if (!disposed)
        {
            // 清理资源
            Console.WriteLine(&quot;资源已释放。&quot;);
            disposed = true;
        }
    }

    ~ResourceHolder()  // 析构函数（Finalizer，垃圾回收时调用）
    {
        Dispose();  // 确保清理
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;using&lt;/code&gt; 语句：&lt;code&gt;using var holder = new ResourceHolder();&lt;/code&gt;（自动 Dispose）。&lt;/p&gt;
&lt;h2&gt;2. 继承（Inheritance）&lt;/h2&gt;
&lt;p&gt;继承实现“Is-A”关系（如 Dog 是 Animal），支持代码复用和多态。C# 只支持单继承（类继承一个基类），但接口多继承。关键：虚方法（virtual）允许重写（override），&lt;code&gt;new&lt;/code&gt; 隐藏基类方法。&lt;/p&gt;
&lt;h3&gt;2.1 基本语法与多态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;:&lt;/code&gt; 继承。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual&lt;/code&gt; / &lt;code&gt;override&lt;/code&gt; 启用运行时多态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;base&lt;/code&gt; 访问基类成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;示例：多态继承（包含隐藏方法）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;using System;

// 基类
public class Shape
{
    protected string Color { get; set; } = &quot;黑色&quot;;

    public Shape(string color)
    {
        Color = color;
    }

    // 虚方法（多态基础）
    public virtual double CalculateArea() =&amp;gt; 0;  // 默认实现

    // 普通方法（用 new 隐藏）
    public void DisplayInfo()
    {
        Console.WriteLine($&quot;形状颜色: {Color}&quot;);
    }
}

// 派生类1
public class Circle : Shape
{
    public double Radius { get; set; }

    public Circle(double radius, string color) : base(color)
    {
        Radius = radius;
    }

    // 重写虚方法（多态）
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }

    // 隐藏基类方法（new 关键字，编译时绑定）
    public new void DisplayInfo()
    {
        Console.WriteLine($&quot;圆形，半径: {Radius}，颜色: {Color}&quot;);
    }
}

// 派生类2（sealed 防止进一步继承）
public sealed class Square : Shape
{
    public double Side { get; set; }

    public Square(double side) : base(&quot;蓝色&quot;)
    {
        Side = side;
    }

    public override double CalculateArea() =&amp;gt; Side * Side;

    // protected 方法示例（仅派生类访问，但 Square 已 sealed）
    protected void InternalMethod() { }
}

// 使用多态
class Program
{
    static void Main()
    {
        Shape[] shapes = {
            new Circle(5, &quot;红色&quot;),
            new Square(4)
        };

        foreach (var shape in shapes)
        {
            Console.WriteLine($&quot;面积: {shape.CalculateArea():F2}&quot;);  // 多态调用
            shape.DisplayInfo();  // Circle 用 new，Square 用 base
        }
        // 输出:
        // 面积: 78.54
        // 圆形，半径: 5，颜色: 红色
        // 面积: 16.00
        // 形状颜色: 蓝色
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出解释&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;多态：&lt;code&gt;shape.CalculateArea()&lt;/code&gt; 根据实际类型调用重写方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; vs &lt;code&gt;override&lt;/code&gt;：&lt;code&gt;new&lt;/code&gt; 是隐藏（静态绑定），不影响基类引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.2 注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造函数链&lt;/strong&gt;：派生类必须调用 &lt;code&gt;base()&lt;/code&gt;，否则隐式调用基类无参构造函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sealed 方法&lt;/strong&gt;：防止重写，如 &lt;code&gt;public sealed override void Method() { }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基类访问&lt;/strong&gt;：&lt;code&gt;base.Property&lt;/code&gt; 或 &lt;code&gt;base.Method()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;陷阱：循环继承（A 继承 B，B 继承 A）编译错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象继承&lt;/strong&gt;：详见抽象类部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.3 扩展用法：对象初始化器与工厂模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对象初始化器（C# 3.0+）：&lt;code&gt;var circle = new Circle { Radius = 5, Color = &quot;绿色&quot; };&lt;/code&gt;（需公共 setter）。&lt;/li&gt;
&lt;li&gt;工厂方法：静态方法创建实例，如 &lt;code&gt;public static Shape CreateCircle(double r) =&amp;gt; new Circle(r, &quot;默认&quot;);&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 接口（Interface）&lt;/h2&gt;
&lt;p&gt;接口定义契约（合同），强制实现类提供特定成员。接口是隐式抽象的，支持多重实现（一个类实现多个接口）。C# 8.0+ 支持默认实现和静态成员。&lt;/p&gt;
&lt;h3&gt;3.1 基本语法与多重实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;接口成员默认 &lt;code&gt;public abstract&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;类用 &lt;code&gt;:&lt;/code&gt; 实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;示例：多接口实现与默认方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;using System;

// 接口1：形状契约
public interface IShape
{
    double Area { get; }  // 属性

    void Draw();  // 抽象方法

    // 默认实现（C# 8.0+）
    void Validate() =&amp;gt; Console.WriteLine(&quot;形状验证通过。&quot;);
}

// 接口2：可序列化
public interface ISerializable
{
    string Serialize();  // 抽象方法

    // 静态方法（C# 8.0+）
    static string GetTypeName(Type t) =&amp;gt; t.Name;
}

// 接口继承（IAdvanced 继承 IShape）
public interface IAdvancedShape : IShape
{
    void Rotate(double angle);
}

// 类实现多接口（显式实现避免冲突）
public class Triangle : IShape, ISerializable, IAdvancedShape
{
    public double Base { get; set; }
    public double Height { get; set; }

    public Triangle(double b, double h)
    {
        Base = b; Height = h;
    }

    // 隐式实现（公共）
    public double Area =&amp;gt; 0.5 * Base * Height;

    public void Draw() =&amp;gt; Console.WriteLine(&quot;绘制三角形。&quot;);

    public void Rotate(double angle) =&amp;gt; Console.WriteLine($&quot;旋转 {angle} 度。&quot;);

    // 显式实现（仅通过接口访问，避免命名冲突）
    string ISerializable.Serialize() =&amp;gt; $&quot;Triangle(Base={Base}, Height={Height})&quot;;

    // 调用默认方法
    public void UseDefault() =&amp;gt; Validate();  // 通过接口调用
}

// 使用
class Program
{
    static void Main()
    {
        Triangle tri = new Triangle(3, 4);
        Console.WriteLine($&quot;面积: {tri.Area}&quot;);  // 6
        tri.Draw();  // 绘制三角形。
        tri.Rotate(90);  // 旋转 90 度。

        // 显式转换访问
        if (tri is ISerializable serial)
            Console.WriteLine(serial.Serialize());  // Triangle(Base=3, Height=4)

        // 静态接口成员
        Console.WriteLine(ISerializable.GetTypeName(typeof(Triangle)));  // Triangle

        tri.UseDefault();  // 形状验证通过。
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;输出解释&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;显式实现：&lt;code&gt;((ISerializable)tri).Serialize()&lt;/code&gt; 访问私有实现。&lt;/li&gt;
&lt;li&gt;默认方法：接口提供体，但类可重写。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.2 注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显式 vs 隐式&lt;/strong&gt;：显式用于冲突，如两个接口同名方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口继承&lt;/strong&gt;：多接口继承，如 &lt;code&gt;interface IAll : IShape, IColor { }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;泛型接口&lt;/strong&gt;：&lt;code&gt;interface IRepository&amp;lt;T&amp;gt; { T GetById(int id); }&lt;/code&gt;（详见扩展）。&lt;/li&gt;
&lt;li&gt;陷阱：接口不能有字段（仅属性/方法），不能实例化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协变/逆变&lt;/strong&gt;（C# 4.0+）：&lt;code&gt;interface IOutput&amp;lt;out T&amp;gt;&lt;/code&gt;（out 用于返回，in 用于参数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.3 扩展用法：泛型接口&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public interface IRepository&amp;lt;T&amp;gt; where T : class  // 约束：T 必须是类
{
    T Get(int id);
    void Add(T item);
    IEnumerable&amp;lt;T&amp;gt; GetAll();
}

public class UserRepository : IRepository&amp;lt;User&amp;gt;
{
    private List&amp;lt;User&amp;gt; users = new();

    public User Get(int id) =&amp;gt; users.FirstOrDefault(u =&amp;gt; u.Id == id);
    public void Add(User item) =&amp;gt; users.Add(item);
    public IEnumerable&amp;lt;User&amp;gt; GetAll() =&amp;gt; users;
}

// User 类简例
public class User { public int Id { get; set; } public string Name { get; set; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;code&gt;var repo = new UserRepository(); var user = repo.Get(1);&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;4. 抽象类（Abstract Class）&lt;/h2&gt;
&lt;p&gt;抽象类提供部分实现，不能实例化，用于共享基类代码。结合虚/抽象方法使用，支持单继承。&lt;/p&gt;
&lt;h3&gt;4.1 基本语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;abstract class&lt;/code&gt; 定义。&lt;/li&gt;
&lt;li&gt;抽象成员无实现，必须派生类提供。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;示例：抽象类与异常集成&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;using System;

public abstract class DatabaseConnection
{
    protected string ConnectionString { get; set; }

    protected DatabaseConnection(string connStr)
    {
        ConnectionString = connStr ?? throw new ArgumentNullException(nameof(connStr));
    }

    // 抽象方法
    public abstract void Connect();

    // 虚方法（可选重写）
    public virtual void Disconnect()
    {
        Console.WriteLine(&quot;断开连接。&quot;);
    }

    // 具体方法（带异常处理）
    public void ExecuteQuery(string query)
    {
        try
        {
            Connect();
            Console.WriteLine($&quot;执行查询: {query}&quot;);
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;查询失败: {ex.Message}&quot;);
            throw;  // 重新抛出
        }
        finally
        {
            Disconnect();
        }
    }
}

public class SqlConnection : DatabaseConnection
{
    public SqlConnection(string connStr) : base(connStr) { }

    public override void Connect()
    {
        if (string.IsNullOrEmpty(ConnectionString))
            throw new InvalidOperationException(&quot;连接字符串无效&quot;);
        Console.WriteLine(&quot;SQL 连接建立。&quot;);
    }

    public override void Disconnect()  // 重写虚方法
    {
        base.Disconnect();
        Console.WriteLine(&quot;SQL 特定清理。&quot;);
    }
}

// 使用
class Program
{
    static void Main()
    {
        var sql = new SqlConnection(&quot;Server=localhost;&quot;);
        sql.ExecuteQuery(&quot;SELECT * FROM Users&quot;);  
        // 输出: SQL 连接建立。
        // 执行查询: SELECT * FROM Users
        // 断开连接。
        // SQL 特定清理。
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4.2 注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;抽象类可有构造函数，但不能直接 &lt;code&gt;new&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;至少一个抽象成员，否则用普通类。&lt;/li&gt;
&lt;li&gt;陷阱：派生类未实现抽象方法 → 编译错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.3 扩展用法：模板方法模式&lt;/h3&gt;
&lt;p&gt;抽象类定义算法骨架，子类实现步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class DataProcessor
{
    public void Process()  // 模板方法
    {
        ValidateData();
        var data = LoadData();
        ProcessData(data);
        SaveData(data);
    }

    protected abstract void ValidateData();
    protected abstract object LoadData();
    protected virtual void ProcessData(object data) { /* 默认 */ }
    protected abstract void SaveData(object data);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;5. 其他高级用法&lt;/h2&gt;
&lt;h3&gt;5.1 泛型（Generics）集成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类/接口/方法泛型：&lt;code&gt;public class Stack&amp;lt;T&amp;gt; { private List&amp;lt;T&amp;gt; items = new(); public void Push(T item) =&amp;gt; items.Add(item); }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;约束：&lt;code&gt;where T : new()&lt;/code&gt;（需无参构造函数）、&lt;code&gt;where T : IComparable&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;示例：&lt;code&gt;Stack&amp;lt;int&amp;gt; intStack = new(); intStack.Push(42);&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.2 委托（Delegate）与事件（Event）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;委托：类型安全的函数指针，如 &lt;code&gt;public delegate void Action(int x);&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;事件：基于委托的发布者，如类中 &lt;code&gt;public event Action&amp;lt;int&amp;gt; OnChanged;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class Publisher
{
    public event EventHandler&amp;lt;int&amp;gt; DataChanged;

    public void RaiseEvent(int value)
    {
        DataChanged?.Invoke(this, value);  // 安全调用
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5.3 LINQ 与 Lambda（简要）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查询语法：&lt;code&gt;var query = from e in employees where e.Salary &amp;gt; 5000 select e;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Lambda：&lt;code&gt;employees.Where(e =&amp;gt; e.Salary &amp;gt; 5000);&lt;/code&gt;（用于方法/属性）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.4 异常处理扩展&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自定义异常：&lt;code&gt;public class CustomException : Exception { public CustomException(string msg) : base(msg) { } }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;全局处理：使用 &lt;code&gt;AppDomain.CurrentDomain.UnhandledException&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类&lt;/strong&gt;：封装与访问控制的核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;继承&lt;/strong&gt;：多态与复用的强大工具（单继承 + 接口多态）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口&lt;/strong&gt;：松耦合契约，支持默认与泛型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象类&lt;/strong&gt;：半实现基类，桥接具体与抽象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文适用于编程思想的入门，对于C#的使用特性会在后续更&lt;/p&gt;
</content:encoded></item><item><title>从C语言入门到c++快速实战：初学者实用指南</title><link>https://windholm.dpdns.org/posts/itplace-cpp/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/itplace-cpp/</guid><description>这篇博客提供C++快速实战教程</description><pubDate>Fri, 14 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;C++ 学习教程：从零基础到游戏开发深度指南&lt;/h3&gt;
&lt;p&gt;欢迎学习 C++！C++ 是一种高效、灵活的编程语言，特别适合游戏开发，因为它能直接访问硬件资源（如内存和 CPU），支持高性能渲染和实时计算。许多知名游戏引擎（如 Unreal Engine、Unity 的底层）都基于 C++。这个教程将从基础开始，逐步深入，到能独立开发简单 2D/3D 游戏的程度。&lt;strong&gt;总深度&lt;/strong&gt;：约 20-30 小时学习 + 练习，目标是让你能用 SFML 库实现一个完整的小游戏（如 Pong 或平台跳跃）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习路径概述&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;预计时间&lt;/th&gt;
&lt;th&gt;目标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 基础设置与语法&lt;/td&gt;
&lt;td&gt;环境、变量、控制流&lt;/td&gt;
&lt;td&gt;2-3 小时&lt;/td&gt;
&lt;td&gt;写简单程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 核心概念&lt;/td&gt;
&lt;td&gt;指针、数组、函数&lt;/td&gt;
&lt;td&gt;4-5 小时&lt;/td&gt;
&lt;td&gt;处理数据结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. 面向对象编程 (OOP)&lt;/td&gt;
&lt;td&gt;类、继承、多态&lt;/td&gt;
&lt;td&gt;5-6 小时&lt;/td&gt;
&lt;td&gt;构建模块化代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4. 标准模板库 (STL)&lt;/td&gt;
&lt;td&gt;容器、算法&lt;/td&gt;
&lt;td&gt;3-4 小时&lt;/td&gt;
&lt;td&gt;高效数据管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5. 高级主题&lt;/td&gt;
&lt;td&gt;异常、文件 I/O、多线程&lt;/td&gt;
&lt;td&gt;4-5 小时&lt;/td&gt;
&lt;td&gt;鲁棒程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6. 游戏开发入门&lt;/td&gt;
&lt;td&gt;SFML 库、图形/输入/物理&lt;/td&gt;
&lt;td&gt;6-8 小时&lt;/td&gt;
&lt;td&gt;开发完整游戏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;练习环境&lt;/strong&gt;：用 Visual Studio Code + MinGW (Windows) 或 g++ (Linux/macOS)。在线测试：&lt;a href=&quot;https://godbolt.org/&quot;&gt;Compiler Explorer&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源&lt;/strong&gt;：书籍《C++ Primer》；视频：Bilibili “黑马程序员 C++ 教程”；刷题：LeetCode C++ 标签。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码示例&lt;/strong&gt;：每个节末有完整代码，可复制运行。编译命令：&lt;code&gt;g++ main.cpp -o main -std=c++17&lt;/code&gt;（用 C++17 标准）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;练习建议&lt;/strong&gt;：每节后做 3-5 个小练习，逐步构建一个项目（如从计算器到游戏）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;阶段 1: 基础设置与语法&lt;/h4&gt;
&lt;p&gt;先设置环境，确保能运行代码。&lt;/p&gt;
&lt;h5&gt;1.1 环境安装&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt;：下载 &lt;a href=&quot;https://www.mingw-w64.org/&quot;&gt;MinGW-w64&lt;/a&gt;，添加 &lt;code&gt;bin&lt;/code&gt; 到 PATH。安装 VS Code + C/C++ 扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;macOS&lt;/strong&gt;：终端运行 &lt;code&gt;xcode-select --install&lt;/code&gt;（安装 g++）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt;：&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install g++ build-essential&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试&lt;/strong&gt;：新建 &lt;code&gt;hello.cpp&lt;/code&gt;：&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;  // 标准输入输出库
int main() {
    std::cout &amp;lt;&amp;lt; &quot;Hello, C++!&quot; &amp;lt;&amp;lt; std::endl;  // 输出
    return 0;  // 程序结束
}
&lt;/code&gt;&lt;/pre&gt;
编译运行：&lt;code&gt;g++ hello.cpp -o hello &amp;amp;&amp;amp; ./hello&lt;/code&gt;。看到 &quot;Hello, C++!&quot; 即成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.2 基本语法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量与类型&lt;/strong&gt;：C++ 是静态类型语言。常见类型：&lt;code&gt;int&lt;/code&gt; (整数)、&lt;code&gt;double&lt;/code&gt; (浮点)、&lt;code&gt;char&lt;/code&gt; (字符)、&lt;code&gt;bool&lt;/code&gt; (真假)、&lt;code&gt;std::string&lt;/code&gt; (字符串)。&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;  // 字符串库
int main() {
    int age = 25;  // 声明并初始化
    double pi = 3.14159;
    std::string name = &quot;Alice&quot;;
    bool is_student = true;

    std::cout &amp;lt;&amp;lt; &quot;Name: &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;, Age: &quot; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入输出&lt;/strong&gt;：用 &lt;code&gt;std::cin&lt;/code&gt; 输入。&lt;pre&gt;&lt;code&gt;int main() {
    int num;
    std::cout &amp;lt;&amp;lt; &quot;Enter a number: &quot;;
    std::cin &amp;gt;&amp;gt; num;
    std::cout &amp;lt;&amp;lt; &quot;You entered: &quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制流&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if-else&lt;/strong&gt;：&lt;pre&gt;&lt;code&gt;if (age &amp;gt;= 18) {
    std::cout &amp;lt;&amp;lt; &quot;Adult&quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &quot;Minor&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环&lt;/strong&gt;：for、while。&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 5; ++i) {  // ++i 是自增
    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot;;
}  // 输出: 0 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;switch&lt;/strong&gt;：多分支。&lt;pre&gt;&lt;code&gt;switch (day) {
    case 1: std::cout &amp;lt;&amp;lt; &quot;Monday&quot;; break;
    default: std::cout &amp;lt;&amp;lt; &quot;Other&quot;; break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写程序计算两个数的和、差。&lt;/li&gt;
&lt;li&gt;用循环打印 1-100 的偶数。&lt;/li&gt;
&lt;li&gt;输入成绩，输出等级 (A:90+ 等)。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;阶段 2: 核心概念&lt;/h4&gt;
&lt;p&gt;掌握内存和函数，为 OOP 铺路。&lt;/p&gt;
&lt;h5&gt;2.1 数组与字符串&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：固定大小集合。&lt;code&gt;int arr[5] = {1,2,3,4,5};&lt;/code&gt;。访问：&lt;code&gt;arr[0]&lt;/code&gt;。&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
int main() {
    int scores[3] = {85, 92, 78};
    for (int i = 0; i &amp;lt; 3; ++i) {
        std::cout &amp;lt;&amp;lt; scores[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态数组&lt;/strong&gt;：用 &lt;code&gt;new&lt;/code&gt; 分配（稍后详解指针）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串&lt;/strong&gt;：&lt;code&gt;std::string&lt;/code&gt; 支持操作如 &lt;code&gt;+=&lt;/code&gt;、&lt;code&gt;length()&lt;/code&gt;。&lt;pre&gt;&lt;code&gt;std::string text = &quot;Hello&quot;;
text += &quot; World!&quot;;
std::cout &amp;lt;&amp;lt; text.length();  // 11
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2.2 函数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;code&gt;返回类型 函数名(参数) { 代码; return 值; }&lt;/code&gt;。&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
int add(int a, int b) {  // 参数
    return a + b;
}
int main() {
    int sum = add(3, 4);
    std::cout &amp;lt;&amp;lt; sum;  // 7
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认参数&lt;/strong&gt;：&lt;code&gt;int multiply(int x, int y = 1) { return x * y; }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重载&lt;/strong&gt;：同名不同参数。&lt;pre&gt;&lt;code&gt;void print(int x) { std::cout &amp;lt;&amp;lt; x; }
void print(double x) { std::cout &amp;lt;&amp;lt; x * 2; }  // 调用时自动匹配
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2.3 指针与引用&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;指针&lt;/strong&gt;：存储地址。&lt;code&gt;int* p = &amp;amp;var;&lt;/code&gt;（&amp;amp; 取地址）。&lt;pre&gt;&lt;code&gt;int main() {
    int x = 10;
    int* ptr = &amp;amp;x;  // ptr 指向 x
    std::cout &amp;lt;&amp;lt; *ptr;  // 解引用: 10
    *ptr = 20;  // 修改 x 为 20
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用&lt;/strong&gt;：别名。&lt;code&gt;int&amp;amp; ref = x; ref = 30;&lt;/code&gt;（x 变 30）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态内存&lt;/strong&gt;：&lt;code&gt;int* arr = new int[5];&lt;/code&gt; 用完 &lt;code&gt;delete[] arr;&lt;/code&gt;（避免内存泄漏）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写函数交换两个数（用指针）。&lt;/li&gt;
&lt;li&gt;用数组计算平均分。&lt;/li&gt;
&lt;li&gt;动态分配字符串数组，存储用户输入。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;阶段 3: 面向对象编程 (OOP)&lt;/h4&gt;
&lt;p&gt;C++ 的核心：类和对象。游戏中用于角色、场景等。&lt;/p&gt;
&lt;h5&gt;3.1 类与对象&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类定义&lt;/strong&gt;：封装数据和方法。&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
class Person {  // 类
private:  // 私有：只能类内访问
    std::string name;
    int age;
public:  // 公有：外部访问
    Person(std::string n, int a) : name(n), age(a) {}  // 构造函数
    void display() { std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; std::endl; }
    ~Person() {}  // 析构函数（清理资源）
};
int main() {
    Person p(&quot;Bob&quot;, 30);  // 对象
    p.display();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问控制&lt;/strong&gt;：private（数据隐藏）、protected（继承可见）、public。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;3.2 继承与多态&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;继承&lt;/strong&gt;：子类扩展父类。&lt;code&gt;class Student : public Person { ... };&lt;/code&gt;。&lt;pre&gt;&lt;code&gt;class Student : public Person {
private:
    std::string major;
public:
    Student(std::string n, int a, std::string m) : Person(n, a), major(m) {}
    void study() { std::cout &amp;lt;&amp;lt; &quot;Studying &quot; &amp;lt;&amp;lt; major &amp;lt;&amp;lt; std::endl; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多态&lt;/strong&gt;：虚函数实现动态绑定。&lt;pre&gt;&lt;code&gt;class Animal {
public:
    virtual void sound() { std::cout &amp;lt;&amp;lt; &quot;Generic sound&quot; &amp;lt;&amp;lt; std::endl; }  // 虚函数
    virtual ~Animal() {}  // 虚析构
};
class Dog : public Animal {
public:
    void sound() override { std::cout &amp;lt;&amp;lt; &quot;Woof!&quot; &amp;lt;&amp;lt; std::endl; }  // 重写
};
int main() {
    Animal* pet = new Dog();  // 基类指针指向子类
    pet-&amp;gt;sound();  // 多态: Woof!
    delete pet;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;3.3 其他 OOP 特性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;友元&lt;/strong&gt;：允许外部访问私有。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运算符重载&lt;/strong&gt;：如 &lt;code&gt;+&lt;/code&gt; for 自定义类型。&lt;pre&gt;&lt;code&gt;class Vector {
public:
    int x, y;
    Vector(int a=0, int b=0) : x(a), y(b) {}
    Vector operator+(const Vector&amp;amp; other) { return Vector(x + other.x, y + other.y); }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 &lt;code&gt;Shape&lt;/code&gt; 基类，派生 &lt;code&gt;Circle&lt;/code&gt;、&lt;code&gt;Rectangle&lt;/code&gt;，计算面积（多态）。&lt;/li&gt;
&lt;li&gt;继承 &lt;code&gt;Vehicle&lt;/code&gt;，实现 &lt;code&gt;Car&lt;/code&gt; 的加速方法。&lt;/li&gt;
&lt;li&gt;用类管理银行账户（存款、取款）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;阶段 4: 标准模板库 (STL)&lt;/h4&gt;
&lt;p&gt;STL 提供现成容器和算法，游戏中用于管理敌人列表、路径查找。&lt;/p&gt;
&lt;h5&gt;4.1 容器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vector&lt;/strong&gt;：动态数组。&lt;pre&gt;&lt;code&gt;#include &amp;lt;vector&amp;gt;
std::vector&amp;lt;int&amp;gt; nums = {1,2,3};
nums.push_back(4);  // 添加
for (int n : nums) { std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; &quot;; }  // 范围 for
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;map&lt;/strong&gt;：键值对（字典）。&lt;code&gt;std::map&amp;lt;std::string, int&amp;gt; scores; scores[&quot;Alice&quot;] = 90;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;set&lt;/strong&gt;：有序唯一集合。&lt;code&gt;std::set&amp;lt;int&amp;gt; unique{1,2,2};&lt;/code&gt;（自动去重）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;4.2 算法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;pre&gt;&lt;code&gt;std::sort(nums.begin(), nums.end());  // 排序
auto it = std::find(nums.begin(), nums.end(), 3);  // 查找
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 vector 存储学生成绩，排序输出。&lt;/li&gt;
&lt;li&gt;用 map 实现单词计数器。&lt;/li&gt;
&lt;li&gt;用 set 去除数组重复元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;阶段 5: 高级主题&lt;/h4&gt;
&lt;p&gt;为游戏添加鲁棒性和并发。&lt;/p&gt;
&lt;h5&gt;5.1 异常处理&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;try { ... } catch (const std::exception&amp;amp; e) { std::cout &amp;lt;&amp;lt; e.what(); }&lt;/code&gt;&lt;pre&gt;&lt;code&gt;try {
    int x = std::stoi(&quot;abc&quot;);  // 转换失败抛异常
} catch (const std::invalid_argument&amp;amp; e) {
    std::cout &amp;lt;&amp;lt; &quot;Invalid input: &quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;5.2 文件 I/O&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;fstream&amp;gt;&lt;/code&gt;&lt;pre&gt;&lt;code&gt;std::ofstream file(&quot;data.txt&quot;);
file &amp;lt;&amp;lt; &quot;Score: 100&quot; &amp;lt;&amp;lt; std::endl;
file.close();

std::ifstream infile(&quot;data.txt&quot;);
std::string line;
while (std::getline(infile, line)) {
    std::cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;5.3 多线程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;thread&amp;gt;&lt;/code&gt;、&lt;code&gt;#include &amp;lt;mutex&amp;gt;&lt;/code&gt;&lt;pre&gt;&lt;code&gt;void task() { std::cout &amp;lt;&amp;lt; &quot;Thread running&quot; &amp;lt;&amp;lt; std::endl; }
int main() {
    std::thread t(task);  // 新线程
    t.join();  // 等待结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
游戏中用于后台加载资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写程序从文件读成绩，计算平均（异常处理）。&lt;/li&gt;
&lt;li&gt;用多线程模拟两个任务并行（打印数字）。&lt;/li&gt;
&lt;li&gt;实现日志系统，线程安全写文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4&gt;阶段 6: 游戏开发入门&lt;/h4&gt;
&lt;p&gt;现在用 SFML 库开发游戏。SFML 是简单快速的多媒体库，支持 2D 图形、音频、输入。&lt;/p&gt;
&lt;h5&gt;6.1 安装 SFML&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;下载 &lt;a href=&quot;https://www.sfml-dev.org/download.php&quot;&gt;SFML&lt;/a&gt;（匹配你的系统）。&lt;/li&gt;
&lt;li&gt;Windows：链接库到项目（VS Code: tasks.json 添加 &lt;code&gt;-lsfml-graphics -lsfml-window -lsfml-system&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;编译：&lt;code&gt;g++ main.cpp -o game -lsfml-graphics -lsfml-window -lsfml-system&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;6.2 基本窗口与事件&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;SFML/Graphics.hpp&amp;gt;
int main() {
    sf::RenderWindow window(sf::VideoMode(800, 600), &quot;My Game&quot;);  // 创建窗口
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) window.close();  // 关闭事件
        }
        window.clear(sf::Color::Black);  // 清屏
        window.display();  // 刷新
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：黑窗口，可关闭。&lt;/p&gt;
&lt;h5&gt;6.3 图形与精灵&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;加载图片：&lt;code&gt;sf::Texture texture; texture.loadFromFile(&quot;sprite.png&quot;); sf::Sprite sprite(texture);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 在循环中
sf::CircleShape shape(50);  // 圆形
shape.setFillColor(sf::Color::Red);
window.draw(shape);  // 绘制
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;6.4 输入与物理&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;键盘：&lt;code&gt;if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) { sprite.move(-5, 0); }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简单物理：用时间步（&lt;code&gt;sf::Clock&lt;/code&gt;）更新位置、碰撞（&lt;code&gt;getGlobalBounds().intersects&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;6.5 完整示例：Pong 游戏&lt;/h5&gt;
&lt;p&gt;实现简单 Pong（球、两个拍子、得分）。完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;SFML/Graphics.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;

int main() {
    sf::RenderWindow window(sf::VideoMode(800, 600), &quot;Pong&quot;);
    sf::RectangleShape paddle1({10, 100}), paddle2({10, 100});  // 拍子
    paddle1.setPosition(10, 250); paddle2.setPosition(780, 250);
    sf::CircleShape ball(10); ball.setPosition(400, 300);  // 球
    sf::Vector2f ballVel(-5, 3);  // 速度
    int score1 = 0, score2 = 0;

    sf::Font font; font.loadFromFile(&quot;arial.ttf&quot;);  // 需要字体文件，或用系统字体
    sf::Text scoreText; scoreText.setFont(font); scoreText.setCharacterSize(24);

    sf::Clock clock;
    while (window.isOpen()) {
        sf::Time dt = clock.restart();  // 时间步
        float deltaTime = dt.asSeconds();

        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) window.close();
        }

        // 输入
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) paddle1.move(0, -300 * deltaTime);
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) paddle1.move(0, 300 * deltaTime);
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up)) paddle2.move(0, -300 * deltaTime);
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down)) paddle2.move(0, 300 * deltaTime);

        // 更新球
        ball.move(ballVel * deltaTime * 60);  // 假设 60 FPS
        // 墙壁反弹
        if (ball.getPosition().y &amp;lt; 0 || ball.getPosition().y &amp;gt; 590) ballVel.y = -ballVel.y;
        // 拍子碰撞
        if (ball.getGlobalBounds().intersects(paddle1.getGlobalBounds()) ||
            ball.getGlobalBounds().intersects(paddle2.getGlobalBounds())) {
            ballVel.x = -ballVel.x;
        }
        // 得分
        if (ball.getPosition().x &amp;lt; 0) { score2++; ball.setPosition(400, 300); ballVel.x = 5; }
        if (ball.getPosition().x &amp;gt; 790) { score1++; ball.setPosition(400, 300); ballVel.x = -5; }

        // 绘制
        window.clear();
        window.draw(paddle1); window.draw(paddle2); window.draw(ball);
        scoreText.setString(&quot;Score: &quot; + std::to_string(score1) + &quot; - &quot; + std::to_string(score2));
        window.draw(scoreText);
        window.display();
    }
    return 0;
}
---&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>xml和json的快速上手：初学者实用指南</title><link>https://windholm.dpdns.org/posts/itplace/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/itplace/</guid><description>这篇博客为编程新手提供xml/json的基础教程，帮助你理解两种语言的核心相似性和差异。</description><pubDate>Wed, 12 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;从XML入门到JSON扩展：初学者实用指南&lt;/h1&gt;
&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;欢迎阅读这份实用指南！如果你是数据格式新手，从XML起步是个好选择。XML（Extensible Markup Language）是结构化数据的“老将”，广泛用于配置文件和文档。随后，我们扩展到JSON（JavaScript Object Notation）——一种轻量级、现代格式，主导Web API和NoSQL数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么这个路径？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML：教你“标签化结构”，强调层次和验证。&lt;/li&gt;
&lt;li&gt;JSON：扩展到“键值对简洁”，更易读写，适合编程集成。&lt;/li&gt;
&lt;li&gt;实用性：每节有示例和练习，使用工具如在线编辑器（XML Validator、JSONLint）或代码（Python/JavaScript）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;：无需安装复杂工具。用浏览器打开在线编辑器，或安装VS Code（带XML/JSON插件）。假设你有基本文本编辑知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习建议&lt;/strong&gt;：边读边验证示例。预计时间：XML入门1周，JSON扩展1周。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;第一部分：XML入门&lt;/h2&gt;
&lt;p&gt;XML是自描述的标记语言，用标签定义数据。核心规则：标签配对、嵌套、属性。&lt;/p&gt;
&lt;h3&gt;1.1 第一个XML：简单文档&lt;/h3&gt;
&lt;p&gt;基本结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/code&gt;：声明。&lt;/li&gt;
&lt;li&gt;根元素：唯一顶级标签。&lt;/li&gt;
&lt;li&gt;关闭标签：&lt;code&gt;&amp;lt;tag&amp;gt;内容&amp;lt;/tag&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例（书籍目录）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;library&amp;gt;
    &amp;lt;book id=&quot;1&quot;&amp;gt;
        &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;John Doe&amp;lt;/author&amp;gt;
        &amp;lt;year&amp;gt;2023&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
    &amp;lt;book id=&quot;2&quot;&amp;gt;
        &amp;lt;title&amp;gt;XML Basics&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;Jane Smith&amp;lt;/author&amp;gt;
        &amp;lt;year&amp;gt;2024&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
&amp;lt;/library&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;验证&lt;/strong&gt;：复制到&lt;a href=&quot;https://www.xmlvalidation.com/&quot;&gt;XML Validator&lt;/a&gt;检查语法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：添加第三本书，包含&lt;code&gt;&amp;lt;price&amp;gt;29.99&amp;lt;/price&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;1.2 元素、属性与命名空间&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;元素：标签内容，如&lt;code&gt;&amp;lt;title&amp;gt;Text&amp;lt;/title&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;属性：标签内附加，如&lt;code&gt;id=&quot;1&quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;命名空间：避免冲突，用&lt;code&gt;xmlns&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例（带属性和命名空间）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;library xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&amp;gt;
    &amp;lt;book id=&quot;1&quot; dc:creator=&quot;John Doe&quot;&amp;gt;
        &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt;
        &amp;lt;year&amp;gt;2023&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
&amp;lt;/library&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;规则&lt;/strong&gt;：属性用引号；元素名区分大小写；无重叠标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：为书籍添加&lt;code&gt;genre=&quot;Fiction&quot;&lt;/code&gt;属性。&lt;/p&gt;
&lt;h3&gt;1.3 DTD与XML Schema（简单验证）&lt;/h3&gt;
&lt;p&gt;DTD（Document Type Definition）：定义结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE library [
    &amp;lt;!ELEMENT library (book+)&amp;gt;
    &amp;lt;!ELEMENT book (title, author, year)&amp;gt;
    &amp;lt;!ELEMENT title (#PCDATA)&amp;gt;
    &amp;lt;!ELEMENT author (#PCDATA)&amp;gt;
    &amp;lt;!ELEMENT year (#PCDATA)&amp;gt;
    &amp;lt;!ATTLIST book id ID #REQUIRED&amp;gt;
]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;置于XML前：&lt;code&gt;&amp;lt;!DOCTYPE library SYSTEM &quot;library.dtd&quot;&amp;gt;&lt;/code&gt;（需外部文件）。&lt;/p&gt;
&lt;p&gt;XML Schema（XSD）：更强大，用XML写。
示例片段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&amp;gt;
    &amp;lt;xs:element name=&quot;library&quot;&amp;gt;
        &amp;lt;xs:complexType&amp;gt;
            &amp;lt;xs:sequence&amp;gt;
                &amp;lt;xs:element name=&quot;book&quot; maxOccurs=&quot;unbounded&quot;&amp;gt;
                    &amp;lt;xs:complexType&amp;gt;
                        &amp;lt;xs:sequence&amp;gt;
                            &amp;lt;xs:element name=&quot;title&quot; type=&quot;xs:string&quot;/&amp;gt;
                            &amp;lt;xs:element name=&quot;author&quot; type=&quot;xs:string&quot;/&amp;gt;
                            &amp;lt;xs:element name=&quot;year&quot; type=&quot;xs:integer&quot;/&amp;gt;
                        &amp;lt;/xs:sequence&amp;gt;
                        &amp;lt;xs:attribute name=&quot;id&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&amp;gt;
                    &amp;lt;/xs:complexType&amp;gt;
                &amp;lt;/xs:element&amp;gt;
            &amp;lt;/xs:sequence&amp;gt;
        &amp;lt;/xs:complexType&amp;gt;
    &amp;lt;/xs:element&amp;gt;
&amp;lt;/xs:schema&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：用在线工具验证你的书籍XML是否符合简单DTD。&lt;/p&gt;
&lt;h3&gt;1.4 XPath查询&lt;/h3&gt;
&lt;p&gt;XPath：XML的“查询语言”，选元素如CSS。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/library/book[1]/title&lt;/code&gt;：第一个书标题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//author&lt;/code&gt;：所有作者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例（用浏览器DevTools或工具测试）：
在XML中，XPath &lt;code&gt;/library/book[@id=&apos;1&apos;]/title&lt;/code&gt; 返回 &quot;Hello World&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：写XPath选所有2023年书籍。&lt;/p&gt;
&lt;h3&gt;1.5 实用项目：产品目录XML&lt;/h3&gt;
&lt;p&gt;整合知识：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE catalog [
    &amp;lt;!ELEMENT catalog (product+)&amp;gt;
    &amp;lt;!ELEMENT product (name, price, description)&amp;gt;
    &amp;lt;!ELEMENT name (#PCDATA)&amp;gt;
    &amp;lt;!ELEMENT price (#PCDATA)&amp;gt;
    &amp;lt;!ELEMENT description (#PCDATA)&amp;gt;
]&amp;gt;
&amp;lt;catalog&amp;gt;
    &amp;lt;product id=&quot;p1&quot;&amp;gt;
        &amp;lt;name&amp;gt;Laptop&amp;lt;/name&amp;gt;
        &amp;lt;price&amp;gt;999.99&amp;lt;/price&amp;gt;
        &amp;lt;description&amp;gt;High-performance laptop.&amp;lt;/description&amp;gt;
    &amp;lt;/product&amp;gt;
    &amp;lt;product id=&quot;p2&quot;&amp;gt;
        &amp;lt;name&amp;gt;Mouse&amp;lt;/name&amp;gt;
        &amp;lt;price&amp;gt;29.99&amp;lt;/price&amp;gt;
        &amp;lt;description&amp;gt;Wireless mouse.&amp;lt;/description&amp;gt;
    &amp;lt;/product&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：添加XSD验证价格为正数。用XPath查询总产品数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XML小结&lt;/strong&gt;：适合复杂文档，但冗长。常见错误：未闭合标签、非法字符。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;第二部分：从XML过渡到JSON&lt;/h2&gt;
&lt;p&gt;XML和JSON都结构化数据，但JSON更简洁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;相似&lt;/strong&gt;：层次（XML元素 → JSON对象/数组）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;XML标签 → JSON键（字符串）。&lt;/li&gt;
&lt;li&gt;无属性/命名空间；纯键值。&lt;/li&gt;
&lt;li&gt;JSON用&lt;code&gt;{}&lt;/code&gt;对象、&lt;code&gt;[]&lt;/code&gt;数组。&lt;/li&gt;
&lt;li&gt;验证：XML用DTD/XSD，JSON用Schema（JSON Schema）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;迁移提示&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML &lt;code&gt;&amp;lt;book&amp;gt;&amp;lt;title&amp;gt;Hi&amp;lt;/title&amp;gt;&amp;lt;/book&amp;gt;&lt;/code&gt; → JSON &lt;code&gt;{&quot;book&quot;: {&quot;title&quot;: &quot;Hi&quot;}}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;工具：在线转换器如&lt;a href=&quot;https://codebeautify.org/xmltojson&quot;&gt;XML to JSON&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例转换：
XML：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;book&amp;gt;&amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt;&amp;lt;author&amp;gt;John&amp;lt;/author&amp;gt;&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSON：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;book&quot;: {
    &quot;title&quot;: &quot;Hello&quot;,
    &quot;author&quot;: &quot;John&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;验证JSON&lt;/strong&gt;：用&lt;a href=&quot;https://jsonlint.com/&quot;&gt;JSONLint&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;第三部分：JSON扩展（高级用法）&lt;/h2&gt;
&lt;p&gt;JSON轻便，易解析。核心：对象（键值对）、数组、基本类型（string, number, boolean, null）。&lt;/p&gt;
&lt;h3&gt;3.1 基本结构与嵌套&lt;/h3&gt;
&lt;p&gt;对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;age&quot;: 30,
  &quot;hobbies&quot;: [&quot;reading&quot;, &quot;coding&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嵌套：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;library&quot;: {
    &quot;books&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;Hello World&quot;,
        &quot;author&quot;: {
          &quot;name&quot;: &quot;John Doe&quot;,
          &quot;email&quot;: &quot;john@example.com&quot;
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：创建用户配置文件JSON，含地址数组。&lt;/p&gt;
&lt;h3&gt;3.2 JSON Schema验证&lt;/h3&gt;
&lt;p&gt;类似XML Schema：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;},
    &quot;age&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0}
  },
  &quot;required&quot;: [&quot;name&quot;, &quot;age&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用在线工具验证JSON。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：为书籍JSON写Schema，要求&lt;code&gt;year&lt;/code&gt; &amp;gt; 1900。&lt;/p&gt;
&lt;h3&gt;3.3 JSONPath查询&lt;/h3&gt;
&lt;p&gt;JSON的XPath类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$.library.books[0].title&lt;/code&gt;：第一本书标题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$..author.name&lt;/code&gt;：所有作者名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;code&gt;$.library.books[?(@.id == 1)].title&lt;/code&gt; 选ID=1的标题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：用&lt;a href=&quot;https://jsonpath.com/&quot;&gt;JSONPath Online Evaluator&lt;/a&gt;查询嵌套JSON。&lt;/p&gt;
&lt;h3&gt;3.4 编程集成（JavaScript/Python示例）&lt;/h3&gt;
&lt;p&gt;JSON天生编程友好。&lt;/p&gt;
&lt;p&gt;JavaScript（解析/生成）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 解析
const jsonStr = &apos;{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}&apos;;
const obj = JSON.parse(jsonStr);
console.log(obj.name);  // Alice

// 生成
const newObj = {name: &quot;Bob&quot;, age: 25};
const jsonStr2 = JSON.stringify(newObj, null, 2);  // 美化
console.log(jsonStr2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json

# 解析
json_str = &apos;{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}&apos;
obj = json.loads(json_str)
print(obj[&apos;name&apos;])  # Alice

# 生成
new_obj = {&apos;name&apos;: &apos;Bob&apos;, &apos;age&apos;: 25}
json_str2 = json.dumps(new_obj, indent=2)
print(json_str2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：写JS脚本从JSON文件读数据，输出作者列表。&lt;/p&gt;
&lt;h3&gt;3.5 实用项目：API响应模拟&lt;/h3&gt;
&lt;p&gt;模拟Web API JSON：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;status&quot;: &quot;success&quot;,
  &quot;data&quot;: {
    &quot;users&quot;: [
      {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Alice&quot;,
        &quot;posts&quot;: [
          {&quot;title&quot;: &quot;First Post&quot;, &quot;likes&quot;: 10},
          {&quot;title&quot;: &quot;Second Post&quot;, &quot;likes&quot;: 5}
        ]
      }
    ],
    &quot;total&quot;: 1
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：用JSON Schema验证。用JSONPath计算总点赞数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON小结&lt;/strong&gt;：适合API和配置。常见错误：逗号遗漏、未引号键。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;结语与资源&lt;/h2&gt;
&lt;p&gt;恭喜！你从XML的“严谨标签”过渡到JSON的“简洁流动”。下一步：实践，如用Postman测试JSON API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML：W3Schools XML教程，书籍《Learning XML》。&lt;/li&gt;
&lt;li&gt;JSON：JSON.org官方指南，书籍《JSON at Work》，在线：MDN Web Docs。&lt;/li&gt;
&lt;li&gt;工具：VS Code扩展，Postman（API测试）。&lt;/li&gt;
&lt;li&gt;社区：Stack Overflow，Reddit r/xml或r/json。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有疑问？多实验转换，坚持实践！🚀&lt;/p&gt;
</content:encoded></item><item><title>从C语言入门到Java扩展：初学者实用指南</title><link>https://windholm.dpdns.org/posts/itplace-yuyan/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/itplace-yuyan/</guid><description>这篇博客为编程新手提供C语言基础教程，并逐步扩展到Java，帮助你理解两种语言的核心相似性和差异。</description><pubDate>Wed, 12 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;从C语言入门到Java扩展：初学者实用指南&lt;/h1&gt;
&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;欢迎阅读这份实用指南！如果你是编程新手，从C语言起步是一个明智的选择。C语言是许多现代语言（如Java）的“祖先”，它能帮助你理解底层概念，如内存管理和程序结构。随后，我们将扩展到Java——一种更现代、面向对象的语言，广泛用于Web开发、Android应用和企业软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么这个路径？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C语言：教你“怎么让计算机做事”，强调效率和基础。&lt;/li&gt;
&lt;li&gt;Java：扩展到“怎么组织代码”，引入面向对象编程（OOP），更易于大规模开发。&lt;/li&gt;
&lt;li&gt;实用性：每节都有代码示例和练习，逐步构建技能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;：安装C编译器（如GCC）和Java开发环境（如JDK + IDE如IntelliJ IDEA或Eclipse）。我们假设你有基本计算机知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习建议&lt;/strong&gt;：边读边敲代码，运行测试。预计时间：C入门1-2周，Java扩展1-2周。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;第一部分：C语言入门&lt;/h2&gt;
&lt;p&gt;C语言简单高效，但需注意细节（如分号和括号）。我们从基础开始。&lt;/p&gt;
&lt;h3&gt;1.1 第一个程序：Hello World&lt;/h3&gt;
&lt;p&gt;C程序的基本结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt;：引入标准输入输出库。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main()&lt;/code&gt;：程序入口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;：输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return 0;&lt;/code&gt;：结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    printf(&quot;Hello, World!\n&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行&lt;/strong&gt;：用&lt;code&gt;gcc hello.c -o hello&lt;/code&gt;编译，然后&lt;code&gt;./hello&lt;/code&gt;执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：修改输出你的名字。&lt;/p&gt;
&lt;h3&gt;1.2 变量与数据类型&lt;/h3&gt;
&lt;p&gt;C使用静态类型：声明时指定类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;：整数（如10）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;：浮点数（如3.14）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;：字符（如&apos;a&apos;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt;：高精度浮点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int age = 25;
    float height = 1.75;
    char grade = &apos;A&apos;;
    
    printf(&quot;Age: %d, Height: %.2f, Grade: %c\n&quot;, age, height, grade);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;格式化输出&lt;/strong&gt;：&lt;code&gt;%d&lt;/code&gt;（int）、&lt;code&gt;%f&lt;/code&gt;（float）、&lt;code&gt;%c&lt;/code&gt;（char）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：计算BMI（体重/身高²），输入体重和身高。&lt;/p&gt;
&lt;h3&gt;1.3 运算符与表达式&lt;/h3&gt;
&lt;p&gt;基本运算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术：&lt;code&gt;+ - * / %&lt;/code&gt;（取模）。&lt;/li&gt;
&lt;li&gt;关系：&lt;code&gt;== != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;逻辑：&lt;code&gt;&amp;amp;&amp;amp; || !&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例（简单计算器）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int a = 10, b = 3;
    printf(&quot;Sum: %d\n&quot;, a + b);
    printf(&quot;Mod: %d\n&quot;, a % b);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：编写判断偶奇数的程序（用&lt;code&gt;% 2 == 0&lt;/code&gt;）。&lt;/p&gt;
&lt;h3&gt;1.4 控制结构&lt;/h3&gt;
&lt;h4&gt;条件语句（if-else）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int score;
    printf(&quot;Enter score: &quot;);
    scanf(&quot;%d&quot;, &amp;amp;score);  // 输入，用&amp;amp;取地址
    
    if (score &amp;gt;= 90) {
        printf(&quot;A\n&quot;);
    } else if (score &amp;gt;= 80) {
        printf(&quot;B\n&quot;);
    } else {
        printf(&quot;C\n&quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;循环（for/while）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt;：已知次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    for (int i = 1; i &amp;lt;= 5; i++) {
        printf(&quot;%d &quot;, i);
    }
    printf(&quot;\n&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;：未知次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int sum = 0, num;
    printf(&quot;Enter numbers (0 to stop): &quot;);
    scanf(&quot;%d&quot;, &amp;amp;num);
    while (num != 0) {
        sum += num;
        scanf(&quot;%d&quot;, &amp;amp;num);
    }
    printf(&quot;Sum: %d\n&quot;, sum);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：打印1-100的斐波那契数列（前20项）。&lt;/p&gt;
&lt;h3&gt;1.5 函数&lt;/h3&gt;
&lt;p&gt;函数封装代码，提高复用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

// 函数声明
int add(int x, int y);

int main() {
    int result = add(5, 3);
    printf(&quot;Result: %d\n&quot;, result);
    return 0;
}

// 函数定义
int add(int x, int y) {
    return x + y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：写一个&lt;code&gt;factorial(int n)&lt;/code&gt;函数计算阶乘。&lt;/p&gt;
&lt;h3&gt;1.6 数组与简单指针&lt;/h3&gt;
&lt;p&gt;数组：存储多个相同类型数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    for (int i = 0; i &amp;lt; 5; i++) {
        printf(&quot;%d &quot;, arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针：变量的地址（C特色，Java无）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    int num = 10;
    int *ptr = &amp;amp;num;  // ptr指向num地址
    printf(&quot;Value: %d, Address: %p\n&quot;, *ptr, ptr);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：用数组计算10个数的平均值。避免深挖指针（初学者易错）。&lt;/p&gt;
&lt;h3&gt;1.7 实用项目：简单计算器&lt;/h3&gt;
&lt;p&gt;整合以上知识：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main() {
    double a, b;
    char op;
    
    printf(&quot;Enter expression (a op b): &quot;);
    scanf(&quot;%lf %c %lf&quot;, &amp;amp;a, &amp;amp;op, &amp;amp;b);
    
    switch (op) {
        case &apos;+&apos;: printf(&quot;%.2f\n&quot;, a + b); break;
        case &apos;-&apos;: printf(&quot;%.2f\n&quot;, a - b); break;
        case &apos;*&apos;: printf(&quot;%.2f\n&quot;, a * b); break;
        case &apos;/&apos;: 
            if (b != 0) printf(&quot;%.2f\n&quot;, a / b);
            else printf(&quot;Error: Division by zero\n&quot;);
            break;
        default: printf(&quot;Invalid operator\n&quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：添加循环支持多计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C小结&lt;/strong&gt;：掌握后，你能写命令行工具。常见错误：忘记&lt;code&gt;;&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;或&lt;code&gt;&amp;amp;&lt;/code&gt;输入。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;第二部分：从C过渡到Java&lt;/h2&gt;
&lt;p&gt;C和Java语法相似（Java受C影响），但Java更安全：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;相似&lt;/strong&gt;：变量、循环、if、函数（Java叫方法）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Java无指针、自动垃圾回收（无&lt;code&gt;free&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;一切是对象：用类封装。&lt;/li&gt;
&lt;li&gt;强类型，但有自动类型转换。&lt;/li&gt;
&lt;li&gt;输入输出：用&lt;code&gt;Scanner&lt;/code&gt;类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;迁移提示&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C的&lt;code&gt;main()&lt;/code&gt; → Java的&lt;code&gt;public static void main(String[] args)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;C的&lt;code&gt;printf/scanf&lt;/code&gt; → Java的&lt;code&gt;System.out.println&lt;/code&gt;和&lt;code&gt;Scanner&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;数组：Java数组是对象，需&lt;code&gt;new&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：C的Hello World到Java。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Java版本
public class Hello {
    public static void main(String[] args) {
        System.out.println(&quot;Hello, World!&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编译运行&lt;/strong&gt;：&lt;code&gt;javac Hello.java&lt;/code&gt;，然后&lt;code&gt;java Hello&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;第三部分：Java扩展（OOP基础）&lt;/h2&gt;
&lt;p&gt;Java的核心是面向对象：类、对象、继承。&lt;/p&gt;
&lt;h3&gt;3.1 类与对象&lt;/h3&gt;
&lt;p&gt;类：蓝图；对象：实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义类
class Person {
    String name;  // 属性
    int age;
    
    void greet() {  // 方法
        System.out.println(&quot;Hi, I&apos;m &quot; + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person();  // 创建对象
        p1.name = &quot;Alice&quot;;
        p1.age = 25;
        p1.greet();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：创建&lt;code&gt;Car&lt;/code&gt;类，有&lt;code&gt;brand&lt;/code&gt;和&lt;code&gt;drive()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3&gt;3.2 构造函数与封装&lt;/h3&gt;
&lt;p&gt;构造函数：初始化对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person {
    private String name;  // private：封装，保护数据
    private int age;
    
    // 构造函数
    public Person(String n, int a) {
        name = n;
        age = a;
    }
    
    // Getter/Setter
    public String getName() { return name; }
    public void setName(String n) { name = n; }
    
    public void greet() {
        System.out.println(&quot;Hi, I&apos;m &quot; + name + &quot;, age &quot; + age);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：用Scanner输入创建Person对象。&lt;/p&gt;
&lt;h3&gt;3.3 继承与多态&lt;/h3&gt;
&lt;p&gt;继承：子类复用父类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal {
    void eat() { System.out.println(&quot;Eating...&quot;); }
}

class Dog extends Animal {  // 继承
    void bark() { System.out.println(&quot;Woof!&quot;); }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();  // 继承的方法
        d.bark();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多态：父类引用子类对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Animal myDog = new Dog();  // 多态
myDog.eat();  // 调用Dog的eat（若重写）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：创建&lt;code&gt;Shape&lt;/code&gt;父类，&lt;code&gt;Circle&lt;/code&gt;子类计算面积。&lt;/p&gt;
&lt;h3&gt;3.4 数组、集合与异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数组：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int[] nums = new int[5];
nums[0] = 1;
// 或 int[] nums = {1,2,3};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;集合（ArrayList，更灵活）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        Scanner sc = new Scanner(System.in);
        String input;
        while (!(input = sc.nextLine()).equals(&quot;quit&quot;)) {
            list.add(input);
        }
        System.out.println(list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;异常处理：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;try {
    int x = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println(&quot;Error: &quot; + e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;：用ArrayList存储学生成绩，计算平均分（处理输入异常）。&lt;/p&gt;
&lt;h3&gt;3.5 实用项目：学生管理系统&lt;/h3&gt;
&lt;p&gt;用OOP构建：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Scanner;

class Student {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    // Getters...
    public String getName() { return name; }
    public int getScore() { return score; }
    
    public String toString() {
        return name + &quot;: &quot; + score;
    }
}

public class StudentManager {
    public static void main(String[] args) {
        ArrayList&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;();
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            System.out.print(&quot;1.Add 2.List 3.Quit: &quot;);
            int choice = sc.nextInt();
            sc.nextLine();  // 消耗换行
            
            if (choice == 1) {
                System.out.print(&quot;Name: &quot;);
                String name = sc.nextLine();
                System.out.print(&quot;Score: &quot;);
                int score = sc.nextInt();
                students.add(new Student(name, score));
            } else if (choice == 2) {
                for (Student s : students) {
                    System.out.println(s);
                }
            } else {
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;：添加删除功能、排序成绩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java小结&lt;/strong&gt;：OOP让代码模块化。常见错误：忘记&lt;code&gt;new&lt;/code&gt;或&lt;code&gt;import&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;结语与资源&lt;/h2&gt;
&lt;p&gt;恭喜！你已从C的“底层魔法”过渡到Java的“对象世界”。下一步：实践项目，如用Java写Web爬虫（需学更多库）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C：书籍《C Primer Plus》，在线：freeCodeCamp C教程。&lt;/li&gt;
&lt;li&gt;Java：Oracle官方文档，书籍《Head First Java》，在线：Coursera “Java Programming”。&lt;/li&gt;
&lt;li&gt;工具：VS Code（插件支持C/Java），LeetCode练习算法。&lt;/li&gt;
&lt;li&gt;社区：Stack Overflow，Reddit r/learnprogramming。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>我的第一篇博客文章</title><link>https://windholm.dpdns.org/posts/nihao/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/nihao/</guid><description>这是我新 Astro 博客的第一篇文章。</description><pubDate>Sun, 02 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;芽衣才是1芽一芽一芽一芽一芽一芽一芽一&lt;/p&gt;
</content:encoded></item><item><title>WindHolm 代码块示例</title><link>https://windholm.dpdns.org/posts/code-examples/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/code-examples/</guid><description>在WindHolm中使用表达性代码的代码块在 Markdown 中的外观。</description><pubDate>Wed, 20 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在这里，我们将探索如何使用 &lt;a href=&quot;https://expressive-code.com/&quot;&gt;Expressive Code&lt;/a&gt; 展示代码块。提供的示例基于官方文档，您可以参考以获取更多详细信息。&lt;/p&gt;
&lt;h2&gt;表达性代&lt;/h2&gt;
&lt;h3&gt;语法高亮&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/syntax-highlighting/&quot;&gt;语法高亮&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;常规语法高亮&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;此代码有语法高亮!&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;渲染 ANSI 转义序列&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ANSI colors:
- Regular: [31mRed[0m [32mGreen[0m [33mYellow[0m [34mBlue[0m [35mMagenta[0m [36mCyan[0m
- Bold:    [1;31mRed[0m [1;32mGreen[0m [1;33mYellow[0m [1;34mBlue[0m [1;35mMagenta[0m [1;36mCyan[0m
- Dimmed:  [2;31mRed[0m [2;32mGreen[0m [2;33mYellow[0m [2;34mBlue[0m [2;35mMagenta[0m [2;36mCyan[0m

256 colors (showing colors 160-177):
[38;5;160m160 [38;5;161m161 [38;5;162m162 [38;5;163m163 [38;5;164m164 [38;5;165m165[0m
[38;5;166m166 [38;5;167m167 [38;5;168m168 [38;5;169m169 [38;5;170m170 [38;5;171m171[0m
[38;5;172m172 [38;5;173m173 [38;5;174m174 [38;5;175m175 [38;5;176m176 [38;5;177m177[0m

Full RGB colors:
[38;2;34;139;34mForestGreen - RGB(34, 139, 34)[0m

Text formatting: [1mBold[0m [2mDimmed[0m [3mItalic[0m [4mUnderline[0m
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;编辑器和终端框架&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/frames/&quot;&gt;编辑器和终端框架&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;代码编辑器框架&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;标题属性示例&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- src/content/index.html --&amp;gt;
&amp;lt;div&amp;gt;文件名注释示例&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;终端框架&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;此终端框架没有标题&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;Write-Output &quot;这个有标题!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;覆盖框架类型&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;看，没有框架!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;# 如果不覆盖，这将是一个终端框架
function Watch-Tail { Get-Content -Tail 20 -Wait $args }
New-Alias tail Watch-Tail
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;文本和行标记&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/text-markers/&quot;&gt;文本和行标记&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;标记整行和行范围&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 第1行 - 通过行号定位
// 第2行
// 第3行
// 第4行 - 通过行号定位
// 第5行
// 第6行
// 第7行 - 通过范围 &quot;7-8&quot; 定位
// 第8行 - 通过范围 &quot;7-8&quot; 定位
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;选择行标记类型 (mark, ins, del)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  console.log(&apos;此行标记为已删除&apos;)
  // 此行和下一行标记为已插入
  console.log(&apos;这是第二个插入行&apos;)

  return &apos;此行使用中性默认标记类型&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;为行标记添加标签&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// labeled-line-markers.jsx
&amp;lt;button
  role=&quot;button&quot;
  {...props}
  value={value}
  className={buttonClassName}
  disabled={disabled}
  active={active}
&amp;gt;
  {children &amp;amp;&amp;amp;
    !active &amp;amp;&amp;amp;
    (typeof children === &apos;string&apos; ? &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt; : children)}
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;在单独行上添加长标签&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// labeled-line-markers.jsx
&amp;lt;button
  role=&quot;button&quot;
  {...props}

  value={value}
  className={buttonClassName}

  disabled={disabled}
  active={active}
&amp;gt;

  {children &amp;amp;&amp;amp;
    !active &amp;amp;&amp;amp;
    (typeof children === &apos;string&apos; ? &amp;lt;span&amp;gt;{children}&amp;lt;/span&amp;gt; : children)}
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用类似 diff 的语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;+此行将标记为已插入
-此行将标记为已删除
这是常规行
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;--- a/README.md
+++ b/README.md
@@ -1,3 +1,4 @@
+this is an actual diff file
-all contents will remain unmodified
 no whitespace will be removed either
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;结合语法高亮和类似 diff 的语法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  function thisIsJavaScript() {
    // 整个块都会以 JavaScript 高亮显示，
    // 并且我们仍然可以为其添加 diff 标记！
-   console.log(&apos;要删除的旧代码&apos;)
+   console.log(&apos;新的闪亮代码！&apos;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;标记行内的单独文本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  // 标记行内的任何给定文本
  return &apos;支持给定文本的多个匹配项&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;正则表达式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;单词 yes 和 yep 将被标记。&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;转义正斜杠&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;Test&quot; &amp;gt; /home/test.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;选择内联标记类型 (mark, ins, del)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function demo() {
  console.log(&apos;这些是插入和删除的标记类型&apos;);
  // return 语句使用默认标记类型
  return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自动换行&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/key-features/word-wrap/&quot;&gt;自动换行&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;为每个块配置自动换行&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 启用换行的示例
function getLongString() {
  return &apos;这是一个非常长的字符串，除非容器极宽，否则很可能无法适应可用空间&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// wrap=false 的示例
function getLongString() {
  return &apos;这是一个非常长的字符串，除非容器极宽，否则很可能无法适应可用空间&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置换行的缩进&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// preserveIndent 示例（默认启用）
function getLongString() {
  return &apos;这是一个非常长的字符串，除非容器极宽，否则很可能无法适应可用空间&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// preserveIndent=false 的示例
function getLongString() {
  return &apos;这是一个非常长的字符串，除非容器极宽，否则很可能无法适应可用空间&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;可折叠部分&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/plugins/collapsible-sections/&quot;&gt;可折叠部分&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 所有这些样板设置代码将被折叠
import { someBoilerplateEngine } from &apos;@example/some-boilerplate&apos;
import { evenMoreBoilerplate } from &apos;@example/even-more-boilerplate&apos;

const engine = someBoilerplateEngine(evenMoreBoilerplate())

// 这部分代码默认可见
engine.doSomething(1, 2, 3, calcFn)

function calcFn() {
  // 您可以有多个折叠部分
  const a = 1
  const b = 2
  const c = a + b

  // 这将保持可见
  console.log(`计算结果: ${a} + ${b} = ${c}`)
  return c
}

// 直到块末尾的所有代码将再次被折叠
engine.closeConnection()
engine.freeMemory()
engine.shutdown({ reason: &apos;示例样板代码结束&apos; })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;行号&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://expressive-code.com/plugins/line-numbers/&quot;&gt;行号&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;为每个块显示行号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 此代码块将显示行号
console.log(&apos;来自第2行的问候!&apos;)
console.log(&apos;我在第3行&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;// 此块禁用行号
console.log(&apos;你好?&apos;)
console.log(&apos;抱歉，你知道我在第几行吗?&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;更改起始行号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;来自第5行的问候!&apos;)
console.log(&apos;我在第6行&apos;)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>在文章中嵌入视频</title><link>https://windholm.dpdns.org/posts/video/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/video/</guid><description>这篇文章演示如何在博客文章中嵌入视频。</description><pubDate>Mon, 01 Aug 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;只需从 YouTube 或其他平台复制嵌入代码，然后将其粘贴到 markdown 文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: 在文章中嵌入视频
published: 2023-10-19
// ...
---

&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&amp;amp;autoplay=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; &amp;amp;autoplay=0&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>Markdown 教程</title><link>https://windholm.dpdns.org/posts/markdown-tutorial/</link><guid isPermaLink="true">https://windholm.dpdns.org/posts/markdown-tutorial/</guid><description>一个简明的 Markdown 博客示例。</description><pubDate>Thu, 01 Jan 1970 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Markdown 教程&lt;/h1&gt;
&lt;p&gt;这是一个展示如何编写 Markdown 文件的示例。本文档汇总了核心语法与常见扩展（GFM）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#block-elements&quot;&gt;块级元素&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#paragraphs-and-line-breaks&quot;&gt;段落与换行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#headers&quot;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#blockquotes&quot;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lists&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code-blocks&quot;&gt;代码块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#horizontal-rules&quot;&gt;分割线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#table&quot;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#span-elements&quot;&gt;内联元素&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#links&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#emphasis&quot;&gt;强调&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code&quot;&gt;行内代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#images&quot;&gt;图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#strikethrough&quot;&gt;删除线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#miscellaneous&quot;&gt;杂项&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#automatic-links&quot;&gt;自动链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#backslash-escapes&quot;&gt;反斜杠转义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#inline-html&quot;&gt;内联 HTML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;a id=&quot;block-elements&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h2&gt;块级元素&lt;/h2&gt;
&lt;p&gt;&amp;lt;a id=&quot;paragraphs-and-line-breaks&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;段落与换行&lt;/h3&gt;
&lt;h4&gt;段落&lt;/h4&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用一个或多个空行分隔段落。（仅包含&lt;strong&gt;空格&lt;/strong&gt;或&lt;strong&gt;制表符&lt;/strong&gt;的行也视为空行。）&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This will be
inline.

This is second paragraph.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This will be
inline.&lt;/p&gt;
&lt;p&gt;This is second paragraph.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;换行&lt;/h4&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在行末添加&lt;strong&gt;两个或更多空格&lt;/strong&gt;来产生换行。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This will be not
inline.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This will be not&lt;br /&gt;
inline.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;headers&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;标题&lt;/h3&gt;
&lt;p&gt;Markdown 支持两种标题样式：Setext 与 atx。&lt;/p&gt;
&lt;h4&gt;Setext&lt;/h4&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;等号 (=)&lt;/strong&gt; 表示 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;、使用&lt;strong&gt;短横线 (-)&lt;/strong&gt; 表示 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;，数量不限，作为“下划线”。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is an H1
=============
This is an H2
-------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;This is an H1&lt;/h1&gt;
&lt;h2&gt;This is an H2&lt;/h2&gt;
&lt;hr /&gt;
&lt;h4&gt;atx&lt;/h4&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h4&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h5&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在行首使用 1-6 个&lt;strong&gt;井号 (#)&lt;/strong&gt;，对应 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 至 &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This is an H1
## This is an H2
###### This is an H6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;This is an H1&lt;/h1&gt;
&lt;h2&gt;This is an H2&lt;/h2&gt;
&lt;h6&gt;This is an H6&lt;/h6&gt;
&lt;hr /&gt;
&lt;p&gt;可选：你可以在行尾“闭合” atx 标题。末尾的井号数量&lt;strong&gt;不必与&lt;/strong&gt;开头一致。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This is an H1 #
## This is an H2 ##
### This is an H3 ######
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;This is an H1&lt;/h1&gt;
&lt;h2&gt;This is an H2&lt;/h2&gt;
&lt;h3&gt;This is an H3&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;blockquotes&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Markdown 使用邮件风格的 &lt;strong&gt;&amp;gt;&lt;/strong&gt; 作为引用符号。若手动换行并在每行前加 &amp;gt;，显示效果最佳。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt;
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/p&gt;
&lt;p&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;Markdown 允许“偷懒”：在一个硬换行段落中，只在第一行前加 &amp;gt; 即可。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;引用可以嵌套（引用中的引用），通过增加 &amp;gt; 层级实现。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;This is the first level of quoting.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is nested blockquote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Back to the first level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;引用内可包含其他 Markdown 元素，包括标题、列表与代码块。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ## This is a header.
&amp;gt;
&amp;gt; 1.   This is the first list item.
&amp;gt; 2.   This is the second list item.
&amp;gt;
&amp;gt; Here&apos;s some example code:
&amp;gt;
&amp;gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;h2&gt;This is a header.&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;This is the first list item.&lt;/li&gt;
&lt;li&gt;This is the second list item.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&apos;s some example code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;lists&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;列表&lt;/h3&gt;
&lt;p&gt;Markdown 支持有序（数字）与无序（圆点）列表。&lt;/p&gt;
&lt;h4&gt;无序列表&lt;/h4&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无序列表可使用 &lt;strong&gt;星号 (*)&lt;/strong&gt;、&lt;strong&gt;加号 (+)&lt;/strong&gt; 或 &lt;strong&gt;短横线 (-)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Red
*   Green
*   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+   Red
+   Green
+   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-   Red
-   Green
-   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;有序列表&lt;/h4&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有序列表使用数字加英文句点：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Bird
2.  McHale
3.  Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;注意：像下面这样可能会“意外触发”有序列表：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1986. What a great season.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;What a great season.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;你可以用&lt;strong&gt;反斜杠转义 (\)&lt;/strong&gt; 句点：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1986\. What a great season.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;1986. What a great season.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;列表中的缩进内容&lt;/h4&gt;
&lt;h5&gt;列表项里的引用&lt;/h5&gt;
&lt;p&gt;在列表项内放置引用，需要将 &amp;gt; 符号整体缩进：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A list item with a blockquote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote
inside a list item.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h5&gt;列表项里的代码块&lt;/h5&gt;
&lt;p&gt;在列表项内放置代码块，需要缩进两层——&lt;strong&gt;8 个空格&lt;/strong&gt;或&lt;strong&gt;两个 Tab&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   A list item with a code block:

        &amp;lt;code goes here&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A list item with a code block:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;code goes here&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h5&gt;嵌套列表&lt;/h5&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* A
  * A1
  * A2
* B
* C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;A
&lt;ul&gt;
&lt;li&gt;A1&lt;/li&gt;
&lt;li&gt;A2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;code-blocks&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;代码块&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将代码块中的每行缩进至少&lt;strong&gt;4 个空格&lt;/strong&gt;或&lt;strong&gt;1 个制表符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is a normal paragraph:

    This is a code block.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This is a normal paragraph:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;代码块会一直持续，直到遇到未缩进的行（或文末）。&lt;/p&gt;
&lt;p&gt;在代码块内，&lt;strong&gt;与号 (&amp;amp;)&lt;/strong&gt; 和尖括号 &lt;strong&gt;(&amp;lt; &amp;gt;)&lt;/strong&gt; 会自动转为 HTML 实体。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&quot;footer&quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;下文的“围栏代码块”和“语法高亮”属于扩展语法，你也可以用它们来书写代码块。&lt;/p&gt;
&lt;h4&gt;围栏代码块&lt;/h4&gt;
&lt;p&gt;使用成对的反引号围起来（如下所示），就不需要四空格缩进了。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Here&apos;s an example:

```
function test() {
  console.log(&quot;notice the blank line before this function?&quot;);
}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Here&apos;s an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test() {
  console.log(&quot;notice the blank line before this function?&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4&gt;语法高亮&lt;/h4&gt;
&lt;p&gt;在围栏代码块后添加可选的语言标识，即可启用语法高亮（参见支持语言列表）。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```ruby
require &apos;redcarpet&apos;
markdown = Redcarpet.new(&quot;Hello World!&quot;)
puts markdown.to_html
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;require &apos;redcarpet&apos;
markdown = Redcarpet.new(&quot;Hello World!&quot;)
puts markdown.to_html
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;horizontal-rules&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;分割线（水平线）&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;hr /&amp;gt;&lt;/code&gt;
一行中放置&lt;strong&gt;三个或以上的短横线 (-)、星号 (*) 或下划线 (_)&lt;/strong&gt;。符号之间允许有空格。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* * *
***
*****
- - -
---------------------------------------
___
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;table&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;表格&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是扩展语法。&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;竖线 (|)&lt;/strong&gt; 分隔列，用&lt;strong&gt;短横线 (-)&lt;/strong&gt; 分隔表头，使用&lt;strong&gt;冒号 (:)&lt;/strong&gt; 指定对齐方式。&lt;/p&gt;
&lt;p&gt;两侧的&lt;strong&gt;竖线 (|)&lt;/strong&gt; 与对齐可选。用于表头分隔时，每列至少需要 &lt;strong&gt;3 个短横线&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| Left | Center | Right |
|:-----|:------:|------:|
|aaa   |bbb     |ccc    |
|ddd   |eee     |fff    |

 A | B
---|---
123|456


A |B
--|--
12|45
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Left&lt;/th&gt;
&lt;th&gt;Center&lt;/th&gt;
&lt;th&gt;Right&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;aaa&lt;/td&gt;
&lt;td&gt;bbb&lt;/td&gt;
&lt;td&gt;ccc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ddd&lt;/td&gt;
&lt;td&gt;eee&lt;/td&gt;
&lt;td&gt;fff&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;123&lt;/td&gt;
&lt;td&gt;456&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;span-elements&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h2&gt;内联元素&lt;/h2&gt;
&lt;p&gt;&amp;lt;a id=&quot;links&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;链接&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Markdown 支持两种链接样式：行内链接与引用式链接。&lt;/p&gt;
&lt;h4&gt;行内链接&lt;/h4&gt;
&lt;p&gt;行内链接格式：&lt;code&gt;[文本](URL &quot;标题&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标题可选。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果引用同一站点的本地资源，可以使用相对路径：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;See my [About](/about/) page for details.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;See my &lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt; page for details.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;引用式链接&lt;/h4&gt;
&lt;p&gt;可以预定义链接引用。定义格式：&lt;code&gt;[id]: URL &quot;标题&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标题同样可选。引用时使用：&lt;code&gt;[文本][id]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: http://example.com/  &quot;Optional Title Here&quot;
This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot;&gt;an example&lt;/a&gt; reference-style link.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方括号中包含链接标识（&lt;strong&gt;不区分大小写&lt;/strong&gt;，可在左侧缩进最多三格空格）；&lt;/li&gt;
&lt;li&gt;随后是冒号；&lt;/li&gt;
&lt;li&gt;再跟一个或多个空格（或 tab）；&lt;/li&gt;
&lt;li&gt;然后是链接 URL；&lt;/li&gt;
&lt;li&gt;URL 可选地用尖括号包裹；&lt;/li&gt;
&lt;li&gt;可选地跟随标题属性，用引号或圆括号包裹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下三种定义等价：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  &apos;Optional Title Here&apos;
[foo]: http://example.com/  (Optional Title Here)
[foo]: &amp;lt;http://example.com/&amp;gt;  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用空的方括号，则链接文本本身会作为名称。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Google]: http://google.com/
[Google][]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;http://google.com/&quot;&gt;Google&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;emphasis&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;强调&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Markdown 使用 &lt;strong&gt;星号 (*)&lt;/strong&gt; 或 &lt;strong&gt;下划线 (_)&lt;/strong&gt; 表示强调。&lt;strong&gt;一个分隔符&lt;/strong&gt;对应 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;；&lt;strong&gt;两个分隔符&lt;/strong&gt;对应 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;single asterisks&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double underscores&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;但如果两侧有空格，则会被视作普通字符而非强调语法。&lt;/p&gt;
&lt;p&gt;你可以使用反斜杠进行转义：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\*this text is surrounded by literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;*this text is surrounded by literal asterisks*&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;code&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;行内代码&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;反引号 (`)&lt;/strong&gt; 包裹。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;若行内代码中需要包含反引号字符，可使用&lt;strong&gt;多重反引号&lt;/strong&gt;作为定界符：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;行内代码两侧的定界符允许包含空格（开头一个、结尾一个），方便在代码起始或结尾放置反引号字符：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;images&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;图片&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Markdown 的图片语法与链接类似，支持行内与引用两种方式。&lt;/p&gt;
&lt;h4&gt;行内图片&lt;/h4&gt;
&lt;p&gt;行内图片语法：&lt;code&gt;![替代文本](URL &quot;标题&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;标题可选。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp&quot; alt=&quot;Alt text&quot; title=&quot;Optional title&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个感叹号 !；&lt;/li&gt;
&lt;li&gt;后接方括号，放置图片的替代文本；&lt;/li&gt;
&lt;li&gt;再接圆括号，内含图片 URL/路径，及可选的标题（引号包裹）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;引用式图片&lt;/h4&gt;
&lt;p&gt;引用式图片语法：&lt;code&gt;![替代文本][id]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[img id]: https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp  &quot;Optional title attribute&quot;
![Alt text][img id]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp&quot; alt=&quot;Alt text&quot; title=&quot;Optional title attribute&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;strikethrough&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;删除线&lt;/h3&gt;
&lt;p&gt;HTML 标签：&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是扩展语法。&lt;/p&gt;
&lt;p&gt;GFM 增加了删除线语法。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~~Mistaken text.~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;s&gt;Mistaken text.&lt;/s&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;miscellaneous&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h2&gt;杂项&lt;/h2&gt;
&lt;p&gt;&amp;lt;a id=&quot;automatic-links&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;自动链接&lt;/h3&gt;
&lt;p&gt;Markdown 支持一种便捷写法来创建“自动链接”（URL 与邮箱地址）：只需用尖括号将其包住即可。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;

&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;GFM 会自动识别标准 URL 并转换为链接。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/emn178/markdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;https://github.com/emn178/markdown&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;a id=&quot;backslash-escapes&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;反斜杠转义&lt;/h3&gt;
&lt;p&gt;Markdown 允许使用反斜杠来转义那些本用于 Markdown 语法的特殊字符，使其按字面显示。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\*literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;*literal asterisks*&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;以下字符可通过反斜杠转义以按字面量输出：&lt;/p&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
+   plus sign
-   minus sign (hyphen)
.   dot
!   exclamation mark
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;a id=&quot;inline-html&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h2&gt;内联 HTML&lt;/h2&gt;
&lt;p&gt;对于 Markdown 语法未覆盖的标记，直接使用原生 HTML 即可。无需特别声明从 Markdown 切换到 HTML，直接写标签就行。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is a regular paragraph.

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

This is another regular paragraph.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This is a regular paragraph.&lt;/p&gt;
&lt;p&gt;&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;p&gt;This is another regular paragraph.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;请注意：在&lt;strong&gt;块级 HTML 标签&lt;/strong&gt;内不会处理 Markdown 语法。&lt;/p&gt;
&lt;p&gt;与块级标签不同，在&lt;strong&gt;行内级标签&lt;/strong&gt;内会处理 Markdown 语法。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span&amp;gt;**Work**&amp;lt;/span&amp;gt;

&amp;lt;div&amp;gt;
    **No Work**
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预览：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;span&amp;gt;&lt;strong&gt;Work&lt;/strong&gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;
&lt;strong&gt;No Work&lt;/strong&gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
</content:encoded></item></channel></rss>