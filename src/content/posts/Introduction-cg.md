# 计算机图形学学习指南（扩展版）

## 一、图形系统与可编程流水线：理解“从无到有”

### 核心概述
计算机图形学是研究如何利用计算机表示、生成、处理和显示图形的学科。它与数字图像处理有着本质区别：后者侧重于对已有像素的操作（如滤镜、压缩、去噪），而图形学更强调从几何模型出发生成像素图像的过程——即“从向量/数学描述到光栅像素”的完整创造流程。这也是为什么图形学常被称作“合成图像”的学科，而非“处理图像”。

### 技术深度
这一领域建立在**图形流水线（Graphics Pipeline）**基础上。它是一个高度并行化的阶段式处理流程，数据从顶点（Vertex）开始，依次经过：
- 顶点处理（Vertex Processing）
- 图元装配（Primitive Assembly）
- 光栅化（Rasterization）
- 片元处理（Fragment Processing）
- 逐像素操作（Per-Pixel Operations）
最终写入帧缓冲区（Framebuffer）形成颜色值。

- **硬件进化**：早期图形卡仅支持固定功能管线（如OpenGL 1.x时代的glBegin/glEnd），计算全部在CPU完成。现代GPU（如NVIDIA RTX系列）拥有数千个流处理器核心，作为协处理器极大减轻CPU负担，支持高度并行计算（如同时处理数百万顶点）。
- **编程范式**：可编程流水线与GLSL（OpenGL Shading Language）是当今主流。开发者可自定义：
  - 顶点着色器（Vertex Shader）：负责坐标变换、皮肤动画等。
  - 片元着色器（Fragment Shader）：负责逐像素颜色、光照计算。
  这彻底取代了固定功能管线，让开发者拥有几乎无限的渲染自由度。现代API（如Vulkan、DirectX 12、Metal）进一步降低了驱动开销，提供更接近硬件的控制。

### 实践建议
入门第一步：使用GLFW（窗口管理）+ GLAD（函数加载）搭建环境，加载着色器程序，绘制一个静态的彩色三角形。这不仅是“现代OpenGL的Hello World”，还能让你快速熟悉核心对象：
- VAO（Vertex Array Object）：绑定顶点属性配置
- VBO（Vertex Buffer Object）：存储顶点数据
- Shader Program：链接顶点与片元着色器
当三角形成功渲染并显示渐变色时，你就真正进入了可编程时代。后续可扩展为动态变换（如随时间旋转），奠定流水线理解基础。

## 二、光栅化与裁剪：离散化的艺术

### 核心概述
光栅化是图形流水线的核心环节，主要解决如何将连续的数学几何图元（直线、圆、多边形）离散化为离散的屏幕像素，并处理超出视口（Viewport）或窗口范围的部分。这是从“向量世界”到“像素世界”的桥梁。

### 经典算法
- **Bresenham 直线算法**（1965年提出）：精髓在于利用整数误差判别（DDA的整数优化版），彻底避开浮点运算与除法，适用于早期无FPU的硬件。算法只用加减和位移，效率极高。
- **中点画圆算法**：利用圆的八分对称性，仅需计算1/8圆弧，通过误差项决定像素选择。同样避免浮点运算。
- **扫描线填充**：针对多边形，使用活性边表（AET）维护当前扫描线与边的交点，按x坐标排序填充像素。
- **裁剪算法**：Cohen-Sutherland（编码裁剪，适合直线）、Sutherland-Hodgman（逐边裁剪多边形）、Liang-Barsky（参数化裁剪）等。

### 现代主流
现代GPU已将光栅化完全硬件化：
- 使用重心坐标（Barycentric Coordinates）并行计算片元属性插值。
- 抗锯齿技术：MSAA（多重采样，在边缘子像素采样）、FXAA/TAA（后处理平滑）、SMAA（形态学抗锯齿）极大改善锯齿现象。
- 超采样与DLSS（AI驱动）进一步提升画质与性能平衡。

### 实践建议
强烈建议动手实现一个纯C语言的软件渲染器（Software Rasterizer）。步骤：
1. 分配一个内存数组模拟帧缓冲（如unsigned char frame[height][width][3]）。
2. 手动实现Bresenham DrawLine和扫描线填充。
3. 将缓冲区写入BMP文件（BMP格式简单，无压缩）。
这能让你在脱离任何图形API的情况下，彻底理解“像素是如何被点亮”的底层逻辑。完成后，你会对GPU的硬件加速产生深刻敬意。

## 三、几何变换与三维观察：图形学的数学核心

### 核心概述
这是图形学中最硬核、最数学化的部分。物体需要在多个坐标系之间转换：模型坐标 → 世界坐标 → 观察（视图）坐标 → 裁剪坐标 → 标准化设备坐标（NDC） → 屏幕坐标，最终实现从三维空间到二维屏幕的投影。

### 数学工具
- **齐次坐标**：将三维坐标(x,y,z)扩展为(x,y,z,1)，使得平移也能用矩阵乘法表示，所有变换（平移、旋转、缩放、错切）统一为4×4矩阵运算。
- **透视投影矩阵**：将视锥体（Frustum）映射为立方体（NDC），通过除以w分量实现“近大远小”。正交投影则用于2D或等距视图。
- **视图矩阵**：通过LookAt（眼位、目标、上方向）构建，实质是世界到观察坐标的逆变换。

### 现代实践
- **四元数（Quaternions）**：比欧拉角优越，避免“万向节死锁”（Gimbal Lock），支持平滑球面线性插值（Slerp），是Unity/Unreal等引擎旋转的标准方式。
- **逆深度缓冲**：传统Z-Buffer在近处精度高、远处低；逆Z（1-z）+浮点缓冲反转分布，提升大规模开放世界（如飞行模拟）的远景精度。
- **双四元数、矩阵分解**等进一步优化复杂动画。

### 实践建议
实现一个交互式3D场景：
1. 用矩阵堆栈实现立方体自转（旋转矩阵随时间变化）。
2. 加入WASD+鼠标控制相机（视图矩阵实时更新）。
3. 添加透视投影观察立方体远近变化。
当你能自由穿梭在自己构建的3D空间、观察物体随视角变形时，你会真正感受到线性代数在图形学中的魔力。这也是后续所有高级渲染（如阴影、反射）的基石。

## 四、三维造型：构建数字世界的骨架

### 核心概述
三维造型研究如何在计算机中高效定义和表示复杂的几何体，包括顶点、边、面、法线、UV等属性。

### 建模方式
- **多边形网格（Mesh）**：最流行、硬件最友好的方式。三角形网格为主，利用**索引缓冲区（EBO/IBO）**共享顶点，显著减少显存与带宽占用。
- **参数曲线/曲面**：
  - Bezier：通过控制点与Bernstein基函数插值，易懂但C1连续性差。
  - B样条：局部控制，支持更高阶连续。
  - NURBS（非均匀有理B样条）：工业标准（汽车、航空CAD），支持精确圆锥曲线。
- **其他表示**：隐式表面（SDF）、体素、体积网格等用于特殊场景。

### 现代进阶
- **曲面细分着色器（Tessellation Shader）**：在GPU运行时根据视角距离动态增加三角形细节（LOD）。
- **网格着色器（Mesh Shader）**：NVIDIA RTX引入，取代传统顶点流水线，可自定义图元生成，支持更高效的剔除与LOD。
- **纳米网格（Nanite）**：Unreal Engine 5的虚拟化微多边形技术，突破传统网格限制。

### 实践建议
从简单开始：
1. 手动构建立方体网格（8顶点+36索引）。
2. 使用Assimp库加载经典.obj（Stanford Bunny）或.fbx模型。
3. 渲染时绑定法线、UV坐标。
当你成功加载并渲染一个复杂角色模型（如游戏角色），你便从“画三角形”迈向了“构建数字世界”的阶段。

## 五、真实感渲染：赋予灵魂的画笔

### 核心概述
真实感渲染旨在模拟真实世界光照、材质与遮挡关系，使画面从“卡通”跨越到“照片级”现实主义。这是图形学的终极追求。

### 关键技术
- **消隐**：Z-Buffer（深度缓冲）逐像素比较深度解决可见性；画家算法（排序后绘制）用于透明物体。
- **局部光照**：Phong/Blinn-Phong模型（环境光 + 漫反射 + 镜面高光）是经典方案，计算简单实时性好。
- **全局光照基础**：光线追踪（Ray Tracing）通过递归模拟光线反射、折射、漫反射，提供阴影、反射、折射、焦散等真实效果。

### 现代渲染趋势
- **PBR（Physically Based Rendering）**：工业标准，基于微表面理论（GGX BRDF），使用金属度/粗糙度工作流，统一离线与实时渲染。
- **高级贴图**：
  - 法线贴图（Normal Mapping）：伪造表面凹凸。
  - 环境贴图（Cube Map/IBL）：图像基光照实现真实反射。
  - PBR贴图集（Albedo、Metallic、Roughness、AO、Height）。
- **实时光追**：NVIDIA RTX硬件加速（BVH+光线核心），支持实时路径追踪、去噪（DLSS）。
- **光栅化+光追混合**：主流游戏方案（如《赛博朋克2077》）。
